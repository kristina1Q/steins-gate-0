//   << 左移：6<<2=24 =6*2的2次方
//  >>右移同理 除2的n次方

/*运算规则是：当运算符两边相同位置都是1时，结果返回1，其他情况都返回0。例如：3 & 5 = 1
0000 0000 0000 0000 0000 0000 0000 0011     -> 3
0000 0000 0000 0000 0000 0000 0000 0101     -> 5
0000 0000 0000 0000 0000 0000 0000 0001     -> 3 & 5 = 1
其中3和5的只有第一位共同为1，所以3 & 5 = 1。*/

/*| 位或运算规则是：当运算符两边相同位置都是0时，结果返回0，其他情况都返回1。3 | 5 = 1*/
/*~ 位非运算规则是：将运算符后二进制数反转，0变1，1变 。例如：~ 3 = -4*/
/*7、^ 位异或运算规则是：当运算符两边相同位置都是相同，结果返回0，不相同时返回1。例如：3 ^ 5 = 1*/
/*我们可以利用 & 运算符的特性，来判断二进制数第一位是0还是1。用if ((a & 1) == 0) 代替 if (a % 2 == 0)来判断a是不是偶数。*/
/*如果考虑到内存，不希望使用临时变量（其实就是为了炫酷），可以这样实现：
a = a + b;
b = a - b;
a = a - b;
从数学角度来分析一下（这个解释很违和，需要在一个频道才能看懂）：
- 第一步：a = a + b
- 第二步：b = a - b = (a + b) - b = a
- 第三步：a = a - b = (a + b) - b = (a + b) - a = b*/
#include <stdio.h>
int main()
{
    int i =64;
    int j,k;
    j= i<<3;
    k=i>>2;
    printf("%d的8倍数:%d\n",i,j);
    printf("%d的1/4倍数:%d\n",i,k);
    return 0;
}


